## redis-benchmark使用

### 1. 使用 redis benchmark 工具, 测试 10 20 50 100 200 1k 5k 字节 value 大小，redis get set 性能。

**Ubuntu Desktop, 32G, i7-9700K 8Core 3.60GHz**

**Redis server v=4.0.9 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=9435c3c2879311f3**

> get
>
> redis-benchmark -h 127.0.0.1 -p 6379 -n 100000 -c 20 -d 10 -t get

| value大小/Byte | 并发连接数/20 | 并发连接数/100 | 并发连接数/1000 | 并发连接数/5000 | 并发连接数/10000 |
| -------------- | ------------- | -------------- | --------------- | --------------- | ---------------- |
| 10             | 164403.56     | 159672.25      | 115952.22       | 92705.442       | 82257.018        |
| 20             | 169918.95     | 160111.442     | 113270.488      | 89769.906       | 85838.878        |
| 50             | 167611.244    | 157948.808     | 110542.084      | 89763.782       | 90261.274        |
| 100            | 175112.71     | 174034.686     | 109055.49       | 102500.66       | 90272.346        |
| 200            | 170738.112    | 161454.146     | 112077.754      | 92878.794       | 89599.19         |
| 1024           | 166185.332    | 159779.134     | 111219.278      | 97570.504       | 84287.782        |
| 5120           | 166343.692    | 163018.222     | 112286.34       | 96089.594       | 83052.626        |

>set
>
>redis-benchmark -h 127.0.0.1 -p 6379 -n 100000 -c 20 -d 10 -t set

| value大小/Byte | 并发连接数/20 | 并发连接数/100 | 并发连接数/1000 | 并发连接数/5000 | 并发连接数/10000 |
| -------------- | ------------- | -------------- | --------------- | --------------- | ---------------- |
| 10             | 178687.064    | 149465.588     | 120738.628      | 82604.72        | 93363.312        |
| 20             | 172919.754    | 150984.98      | 130914.494      | 87657.334       | 94443.476        |
| 50             | 183595.416    | 159954.372     | 126001.474      | 85667.244       | 98108.1          |
| 100            | 174260.63     | 149986.156     | 121376.59       | 86961.54        | 91083.664        |
| 200            | 161978.3      | 144783.862     | 116360.398      | 88730.662       | 98886.222        |
| 1024           | 166067.274    | 142312.504     | 116911.7        | 90662.65        | 95132.896        |
| 5120           | 152572.912    | 126029.244     | 108141.162      | 82902.038       | 88725.882        |

**Raspberry Pi 4 Model B Rev 1.1, 8G, 4Core 1.5GHz**

> 测试数据待补充，发现树莓派的性能远远弱于上述机器的性能，粗略计算，性能相差10倍

### 2. 写入一定量的 kv 数据, 根据数据大小 1w-50w 自己评估, 结合写入前后的 info memory 信息  , 分析上述不同 value 大小下，平均每个 key 的占用内存空间。

> key的长度为6，000001, 000002, 000003, …
>
> 实际有效数据占比=(key len + value len) / 均key大小，如(6+10)/130.208≈12.29%

| value大小/Byte | 1w，均key大小/实际有效数据占比 | 2w，均key大小 | 10w，均key大小 | 20w，均key大小 |
| -------------- | ------------------------------ | ------------- | -------------- | -------------- |
| 10             | 130.208/12.29%                 | 130.2112      | 124.97088      | 124.9712       |
| 20             | 146.208/17.78%                 | 146.2112      | 140.97088      | 140.9712       |
| 50             | 178.208/31.42%                 | 178.2112      | 172.97088      | 172.9712       |
| 100            | 226.208/46.86%                 | 226.2112      | 220.97088      | 220.9712       |
| 200            | 338.208/60.91%                 | 338.2112      | 332.97088      | 332.9712       |
| 1024           | 1394.208/73.88%                | 1394.2112     | 1388.97088     | 1388.9712      |
| 5120           | 6258.208/81.91%                | 6258.2112     | 6252.97088     | 6252.9712      |

- 为什么当key大时，均key对应的value大小会变小，从测试数据看，少了6B？
- 当key长度相同时，随着value的增大，有效数据的内存占比会越高。当调用`set key value`时，除了实际数据，redis还会增加额外的元数据。

### 3. set 单key测试

> 该测试的一些知识主要参考[《Redis核心技术与实战》](https://time.geekbang.org/column/article/279649)中第11讲内容。
>
> [redis string编码方式_1](https://zhuanlan.zhihu.com/p/166534258) 
>
> [redis string编码方式_2](https://juejin.cn/post/6886726965030551559)
>
> OBJECT encoding 可查看编码方式

```
set 000001 abcdabcdab  树莓派/PC,内存增长72B;均为embstr编码方式
set 000001 1234567890  树莓派机器上,内存增长56B;PC上,内存增长72B;均为int编码
```

当保存的key/value为整型时，redis对其进行了优化，string类型会将它保存为一个**8字节**的long类型证书，即int编码方式。同时每个数据都会包含一些元数据(主要用来记录最后一次访问的时间等等信息)，redis用一个**RedisObject**结构体来统一保存元数据并指向实际数据。

每个**RedisObject**包含一个8字节的元数据和一个8字节指针(指向具体数据类型的实际数据)。

因此，当key/value均为整型数时，根据以上信息获取，**8+8+8+8=32B**，其余的56-32=24B是什么数据？redis拥有一个全局哈希表，主要用来保存所有键值对，每一项是一个**dictEntry**结构体(**有三个8字节的指针**)，用来指向一个键值对。

3个指针共24B，再按照jemalloc内存分配规则，即返回32B内存空间供使用。综上：

- key/value，均为int编码方式时，占用总内存为32+32=64B

#### 疑问

**1. set 000001 1234567890 结果为什么与分析的不一致？**

> 临时将redis进行了升级(Redis server v=6.0.14 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=48f7954164be2de1)，发现`set 000001 1234567890`内存只增加了48B，这个问题得抽点时间好好查查资料了。
>
> note: 查询资料发现，redis有一个[共享对象池](https://cloud.tencent.com/developer/article/1162213)概念，以便节约内存，预创建，通过``object refcount`发现的确使用了。

树莓派，32+24=56B，在树莓派系统下，分配**dictEntry**内存时，为什么会是24B，不是32B(**可能该系统下按照实际内存分配，原因待解**)？

PC上，实测占用内存72B，与分析的结果多8字节，该字节是什么数据(创建全局哈希表时产生的？)？

```
redis-memory-for-key 000001      
Key				000001
Bytes				56
Type				string
```

如上所示，通过工具显示，该key实际占用了56B(8+8+8+8+24)，因为jemalloc的分配策略内存会增长64B。但是通过`info memory`对比前后内存，发现增长了72B，多的8字节，该字节是什么数据？

